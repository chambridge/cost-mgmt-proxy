worker_processes auto;
error_log /dev/stderr debug;

events {
    worker_connections 1024;
}

http {
    include             mime.types;
    default_type        application/octet-stream;
    sendfile            on;
    keepalive_timeout   65;

    lua_shared_dict token_cache 10m;

    upstream cost_mgmt_backend {
        server console.redhat.com:443;
    }

    access_log /dev/stdout;

    env CLIENT_ID;
    env CLIENT_SECRET;

    server {
        listen 8080;
        

        location /api/cost-management {
            resolver 8.8.8.8;

            set $auth_token "";
            access_by_lua_block {
                local http = require "resty.http"
                local cjson = require "cjson.safe"
                local ngx_shared = ngx.shared.token_cache

                local CLIENT_ID = os.getenv("CLIENT_ID")
                local CLIENT_SECRET = os.getenv("CLIENT_SECRET")
                local TOKEN_ENDPOINT = "https://sso.redhat.com/auth/realms/redhat-external/protocol/openid-connect/token"

                if CLIENT_ID then
                    ngx.log(ngnx.ERR, "CLIENT_ID found: " .. CLIENT_ID)
                else
                    ngx.log(ngx.ERR, "CLIENT_ID is missing or nil")
                end

                if CLIENT_SECRET then
                    ngx.log(ngnx.ERR, "CLIENT_SECRET found: " .. CLIENT_SECRET)
                else
                    ngx.log(ngx.ERR, "CLIENT_SECRET is missing or nil")
                end

                local token, _ = ngx_shared:get("bearer_token")
                if not token then
                    local httpc = http.new()
                    local res, err = httpc:request_uri(TOKEN_ENDPOINT, {
                        method = "POST",
                        body = "grant_type=client_credentials&client_id" .. CLIENT_ID .. "&client_secret=" .. CLIENT_SECRET,
                        headers {
                            ["Content-Type"] = "application/x-www-form-urlencoded"
                        },
                        ssl_verify = false
                    })
                    if res and res.status == 200 then
                        local body = cjson.decode(res.body)
                        token = body["access_token"]
                        ngx_shared:set("bearer_token", token, body["expires_in"] - 30)
                    else
                        ngx.log(ngx.ERR, "Failed to get token: ", err)
                    end
                end

                ngx.var.auth_token = token or ""
            }

            proxy_set_header Authorization "Bearer $auth_token";
            proxy_pass https://cost_mgmt_backend;
        }
    }
}